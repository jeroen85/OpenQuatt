# ==============================================================================
# OpenQuatt - Heat Control Policy (single allocator)
# ==============================================================================
# Contains only single-setup allocation logic.
# Shared sensors/globals/buttons live in oq_heat_control.yaml.
# ==============================================================================

interval:
  - interval: ${oq_heat_loop_s}s
    then:
      - lambda: |-
          const uint32_t now_ms = (uint32_t) millis();
          const int demand_max_f = (int) ${oq_strategy_demand_max_f};

          int raw = id(oq_demand_raw);
          raw = std::max(0, std::min(demand_max_f, raw));

          int ramp_up_step_min = (int) lroundf(id(oq_demand_filter_ramp_up_step_min).state);
          if (ramp_up_step_min < 1) ramp_up_step_min = 1;
          if (ramp_up_step_min > demand_max_f) ramp_up_step_min = demand_max_f;

          int f = id(oq_demand_filtered);
          if (raw > f) {
            f = std::min(f + ramp_up_step_min, raw);
          } else if (raw == 0 && f == 1) {
            f = 0;
          } else if (raw <= (f - 2)) {
            f = raw;
          }
          f = std::max(0, std::min(demand_max_f, f));

          int f_cap = id(oq_power_cap_f);
          f_cap = std::max(0, std::min(demand_max_f, f_cap));
          if (f > f_cap) f = f_cap;

          id(oq_demand_filtered) = f;

          auto level_allowed = [&](int level)->bool {
            switch (level) {
              case 1: return id(hp1_lvl_1).state;
              case 2: return id(hp1_lvl_2).state;
              case 3: return id(hp1_lvl_3).state;
              case 4: return id(hp1_lvl_4).state;
              case 5: return id(hp1_lvl_5).state;
              case 6: return id(hp1_lvl_6).state;
              case 7: return id(hp1_lvl_7).state;
              case 8: return id(hp1_lvl_8).state;
              case 9: return id(hp1_lvl_9).state;
              case 10: return id(hp1_lvl_10).state;
              default: return true;
            }
          };

          auto pick_allowed = [&](int req)->int {
            if (req <= 0) return 0;
            req = std::max(1, std::min(10, req));
            if (level_allowed(req)) return req;
            for (int l = req - 1; l >= 1; l--) if (level_allowed(l)) return l;
            for (int l = req + 1; l <= 10; l++) if (level_allowed(l)) return l;
            return 0;
          };

          int level_cap = (int) roundf(id(oq_day_max_level).state);
          if (id(oq_silent_active).state) level_cap = (int) roundf(id(oq_silent_max_level).state);
          level_cap = std::max(0, std::min(10, level_cap));

          const float Tamb = id(outside_temp_selected).state;
          const float Tsup = id(oq_system_supply_temp).state;
          float cap_w = 0.0f;
          if (!isnan(Tamb) && !isnan(Tsup) && level_cap > 0) {
            for (int lvl = 1; lvl <= level_cap; lvl++) {
              if (!level_allowed(lvl)) continue;
              const float p = oq_perf::interp_power_th_w(lvl, Tamb, Tsup);
              if (!isnan(p) && p > cap_w) cap_w = p;
            }
          }
          id(oq_P_hp_cap_w) = cap_w;

          float req_w = id(oq_phouse_req_w);
          if (isnan(req_w)) req_w = 0.0f;
          float deficit_w = req_w - cap_w;
          if (deficit_w < 0.0f) deficit_w = 0.0f;
          id(oq_P_deficit_w) = deficit_w;

          const int cm_code = id(oq_control_mode_code);
          const bool cm_allows_hp = (cm_code == 2 || cm_code == 3);
          const char* lvl_opts[11] = {"0","1","2","3","4","5","6","7","8","9","10"};

          auto set_mode = [&](bool heating) {
            const char* opt = heating ? "Heating" : "Standby";
            if (!id(hp1_set_working_mode).has_state() || id(hp1_set_working_mode).current_option() != opt) {
              auto c = id(hp1_set_working_mode).make_call();
              c.set_option(opt);
              c.perform();
            }
          };

          auto mode_is_heating = [&]()->bool {
            const float m = id(hp1_working_mode).state;
            return !isnan(m) && ((int) roundf(m) == 2);
          };

          auto mode_target_is_heating = [&]()->bool {
            return id(hp1_set_working_mode).has_state() && id(hp1_set_working_mode).current_option() == "Heating";
          };

          auto apply_level = [&](int req_level)->int {
            req_level = std::max(0, std::min(10, req_level));
            if (req_level > 0) set_mode(true);
            else set_mode(false);

            int applied = req_level;
            if (applied > level_cap) applied = level_cap;

            if (req_level > 0 && !mode_is_heating() && !mode_target_is_heating()) {
              applied = 0;
            }

            auto idx = id(hp1_compressor_level).active_index();
            const int cur = idx.has_value() ? (int) idx.value() : -1;
            if (cur != applied) {
              auto c = id(hp1_compressor_level).make_call();
              c.set_option(lvl_opts[applied]);
              c.perform();
            }

            return applied;
          };

          if (!cm_allows_hp) {
            set_mode(false);
            apply_level(0);
            if (id(hp1_last_applied_level) > 0) id(hp1_last_stop_ms) = now_ms;
            id(hp1_last_applied_level) = 0;
            return;
          }

          int hp1_req = 0;
          if (f > 0 && level_cap > 0) {
            hp1_req = (f * level_cap + demand_max_f - 1) / demand_max_f;
            hp1_req = std::max(1, std::min(level_cap, hp1_req));
          }

          hp1_req = pick_allowed(hp1_req);

          const int min_rt = (int) roundf(id(oq_min_runtime_min).state);
          if (min_rt > 0) {
            const uint32_t min_rt_ms = (uint32_t) min_rt * 60000UL;
            const uint32_t hp1_rt_ms = (uint32_t) (now_ms - id(hp1_last_start_ms));
            if (hp1_req == 0 && id(hp1_last_applied_level) > 0 && hp1_rt_ms < min_rt_ms) {
              hp1_req = pick_allowed(1);
            }
          }

          const int hp1_applied = apply_level(hp1_req);
          const int prev = id(hp1_last_applied_level);

          if (prev == 0 && hp1_applied > 0) {
            id(hp1_last_start_ms) = now_ms;
          } else if (prev > 0 && hp1_applied == 0) {
            id(hp1_last_stop_ms) = now_ms;
          }

          if (hp1_applied > 0) {
            const float mode_raw = id(hp1_working_mode).state;
            const bool heating_now = !isnan(mode_raw) && ((int) roundf(mode_raw) == 2);
            if (heating_now) id(hp1_minutes)++;
          }

          id(hp1_last_applied_level) = hp1_applied;
