# ==============================================================================
# OpenQuatt - Heating Strategy (Power House vs Heating Curve)
# ==============================================================================
#
# Goal:
#   Determines the heat-demand source and outputs one normalized demand:
#     - oq_demand_raw  (0..20)
#
# Strategies:
#   1) Power House
#      - Computes heat demand from house parameters, outdoor/room temperature, and ramp/deadband
#      - Converts requested thermal power to demand 0..20 (`oq_demand_raw`)
#
#   2) Heating Curve
#      - 6-point heating curve (Tout -> Tsupply_target) with linear interpolation
#      - PI control on abstracted system supply temperature (PV = oq_system_supply_temp) to Tsupply_target
#      - PI output is directly translated to demand 0..20
#
# Transition:
#   - Mode switch is immediate; on mode change, PID integral and latch states are reset.
#
# Ownership:
#   - Only this package writes oq_demand_raw.
#   - Heat control consumes oq_demand_raw and otherwise remains unchanged.
# ==============================================================================

# ----------------------------
# CONTROL INPUTS
# ----------------------------
select:
  - platform: template
    id: oq_heat_control_mode
    name: "Heating Control Mode"
    icon: mdi:tune-variant
    optimistic: true
    restore_value: true
    options:
      - Power House
      - Water Temperature Control (heating curve)
    initial_option: Power House
    web_server:
      sorting_group_id: oq_control
    on_value:
      then:
        # Reset PID integral when strategy changes to prevent carry-over between modes.
        - climate.pid.reset_integral_term: oq_heating_curve_pid
        - lambda: |-
            id(oq_curve_heat_request_active) = false;
            id(oq_curve_outside_ema_initialized) = false;
            id(oq_curve_outside_ema_last_ms) = 0;
            id(oq_ph_comfort_bias_last_ms) = 0;
            id(oq_ph_room_error_avg_init) = false;

  - platform: template
    id: oq_curve_control_profile
    name: "Heating Curve Control Profile"
    icon: mdi:tune-variant
    optimistic: true
    restore_value: true
    options:
      - Comfort
      - Balanced
      - Stable
    initial_option: Balanced
    entity_category: config
    web_server:
      sorting_group_id: oq_tuning_heat
    on_value:
      then:
        - climate.pid.reset_integral_term: oq_heating_curve_pid
        - lambda: |-
            id(oq_curve_heat_request_active) = false;
            id(oq_curve_outside_ema_initialized) = false;
            id(oq_curve_outside_ema_last_ms) = 0;

# ----------------------------
# TUNING INPUTS
# POWER HOUSE - House heat-loss parameters (configurable)
# Interpretation:
# - house_rated_power_w at house_cold_temp_c (default 7020 W @ -10°C)
# - 0 W at house_zero_power_temp_c (default 16°C)
# ----------------------------
number:
  - platform: template
    id: house_cold_temp_c
    name: "House cold temp"
    icon: mdi:thermometer-low
    unit_of_measurement: "°C"
    min_value: -25
    max_value: 5
    step: 0.5
    restore_value: true
    optimistic: true
    initial_value: -10
    entity_category: config
    web_server:
      sorting_group_id: oq_tuning_heat

  - platform: template
    id: house_rated_power_w
    name: "Rated maximum house power"
    icon: mdi:home-lightning-bolt
    unit_of_measurement: "W"
    min_value: 1000
    max_value: 15000
    step: 10
    restore_value: true
    optimistic: true
    initial_value: 7020
    entity_category: config
    web_server:
      sorting_group_id: oq_tuning_heat

  - platform: template
    id: house_zero_power_temp_c
    name: "Maximum heating outdoor temperature"
    icon: mdi:thermometer-high
    unit_of_measurement: "°C"
    min_value: 5
    max_value: 25
    step: 0.5
    restore_value: true
    optimistic: true
    initial_value: 16
    entity_category: config
    web_server:
      sorting_group_id: oq_tuning_heat

  - platform: template
    id: ph_kp_w_per_k
    name: "Power House Kp (W-K)"
    icon: mdi:function-variant
    unit_of_measurement: "W/K"
    min_value: 0
    max_value: 4000
    step: 10
    restore_value: true
    optimistic: true
    initial_value: 2000
    entity_category: config
    web_server:
      sorting_group_id: oq_tuning_heat

  - platform: template
    id: ph_deadband_k
    name: "Power House deadband"
    icon: mdi:chart-bell-curve-cumulative
    unit_of_measurement: "K"
    min_value: 0
    max_value: 1.0
    step: 0.01
    restore_value: true
    optimistic: true
    initial_value: ${oq_ph_deadband_default_k}
    entity_category: config
    web_server:
      sorting_group_id: oq_tuning_heat

  - platform: template
    id: ph_comfort_band_below_c
    name: "Power House comfort below setpoint"
    icon: mdi:thermometer-chevron-down
    unit_of_measurement: "°C"
    min_value: 0
    max_value: 2.0
    step: 0.05
    restore_value: true
    optimistic: true
    initial_value: 0.1
    entity_category: config
    web_server:
      sorting_group_id: oq_tuning_heat

  - platform: template
    id: ph_comfort_band_above_c
    name: "Power House comfort above setpoint"
    icon: mdi:thermometer-chevron-up
    unit_of_measurement: "°C"
    min_value: 0
    max_value: 2.0
    step: 0.05
    restore_value: true
    optimistic: true
    initial_value: 0.3
    entity_category: config
    web_server:
      sorting_group_id: oq_tuning_heat

  - platform: template
    id: ph_comfort_bias_base_c
    name: "Power House comfort bias base"
    icon: mdi:thermometer-plus
    unit_of_measurement: "°C"
    min_value: 0.0
    max_value: 0.5
    step: 0.05
    restore_value: true
    optimistic: true
    initial_value: 0.1
    entity_category: config
    web_server:
      sorting_group_id: oq_tuning_heat

  - platform: template
    id: ph_comfort_bias_max_c
    name: "Power House comfort bias max"
    icon: mdi:thermometer-high
    unit_of_measurement: "°C"
    min_value: 0.0
    max_value: 0.5
    step: 0.05
    restore_value: true
    optimistic: true
    initial_value: 0.5
    entity_category: config
    web_server:
      sorting_group_id: oq_tuning_heat

  - platform: template
    id: ph_comfort_bias_up_c_per_h
    name: "Power House comfort bias up"
    icon: mdi:arrow-up-bold
    unit_of_measurement: "°C/h"
    min_value: 0.0
    max_value: 0.5
    step: 0.01
    restore_value: true
    optimistic: true
    initial_value: 0.08
    entity_category: config
    web_server:
      sorting_group_id: oq_tuning_heat

  - platform: template
    id: ph_comfort_bias_down_c_per_h
    name: "Power House comfort bias down"
    icon: mdi:arrow-down-bold
    unit_of_measurement: "°C/h"
    min_value: 0.0
    max_value: 1.0
    step: 0.01
    restore_value: true
    optimistic: true
    initial_value: 0.20
    entity_category: config
    web_server:
      sorting_group_id: oq_tuning_heat

  - platform: template
    id: ph_room_error_avg_tau_min
    name: "Power House room error avg tau"
    icon: mdi:chart-timeline-variant
    unit_of_measurement: "min"
    min_value: 5
    max_value: 120
    step: 5
    restore_value: true
    optimistic: true
    initial_value: 30
    entity_category: config
    web_server:
      sorting_group_id: oq_tuning_heat

  - platform: template
    id: ph_ramp_up_w_per_min
    name: "Power House ramp up"
    icon: mdi:chart-line-variant
    unit_of_measurement: "W/min"
    min_value: 0
    max_value: 3000
    step: 10
    restore_value: true
    optimistic: true
    initial_value: 853.7781041357721
    entity_category: config
    web_server:
      sorting_group_id: oq_tuning_heat

  - platform: template
    id: ph_ramp_down_w_per_min
    name: "Power House ramp down"
    icon: mdi:chart-line
    unit_of_measurement: "W/min"
    min_value: 0
    max_value: 5000
    step: 10
    restore_value: true
    optimistic: true
    initial_value: 2421.504843770334
    entity_category: config
    web_server:
      sorting_group_id: oq_tuning_heat

# ----------------------------
# CURVE CONFIG (6-point)
# Tout = -20, -10, 0, 5, 10, 15 °C
# Tsupply_target is linearly interpolated per segment.
# ----------------------------

  - platform: template
    id: curve_tsupply_m20
    name: "Curve Tsupply @ -20°C"
    icon: mdi:thermometer
    unit_of_measurement: "°C"
    min_value: 20
    max_value: 70
    step: 0.5
    restore_value: true
    optimistic: true
    initial_value: 55
    web_server:
      sorting_group_id: oq_tuning_heat

  - platform: template
    id: curve_tsupply_m10
    name: "Curve Tsupply @ -10°C"
    icon: mdi:thermometer
    unit_of_measurement: "°C"
    min_value: 20
    max_value: 70
    step: 0.5
    restore_value: true
    optimistic: true
    initial_value: 50
    web_server:
      sorting_group_id: oq_tuning_heat

  - platform: template
    id: curve_tsupply_0
    name: "Curve Tsupply @ 0°C"
    icon: mdi:thermometer
    unit_of_measurement: "°C"
    min_value: 20
    max_value: 70
    step: 0.5
    restore_value: true
    optimistic: true
    initial_value: 45
    web_server:
      sorting_group_id: oq_tuning_heat

  - platform: template
    id: curve_tsupply_5
    name: "Curve Tsupply @ 5°C"
    icon: mdi:thermometer
    unit_of_measurement: "°C"
    min_value: 20
    max_value: 70
    step: 0.5
    restore_value: true
    optimistic: true
    initial_value: 40
    web_server:
      sorting_group_id: oq_tuning_heat

  - platform: template
    id: curve_tsupply_10
    name: "Curve Tsupply @ 10°C"
    icon: mdi:thermometer
    unit_of_measurement: "°C"
    min_value: 20
    max_value: 70
    step: 0.5
    restore_value: true
    optimistic: true
    initial_value: 35
    web_server:
      sorting_group_id: oq_tuning_heat

  - platform: template
    id: curve_tsupply_15
    name: "Curve Tsupply @ 15°C"
    icon: mdi:thermometer
    unit_of_measurement: "°C"
    min_value: 20
    max_value: 70
    step: 0.5
    restore_value: true
    optimistic: true
    initial_value: 30
    web_server:
      sorting_group_id: oq_tuning_heat

  # ----------------------------
  # PID TUNING (configurable) - Heating Curve PID
  # PID output is 0..1 and is scaled to demand 0..20 via heating_curve_pid_out
  # ----------------------------
  - platform: template
    id: heating_curve_pid_kp
    name: "Heating Curve PID Kp"
    icon: mdi:alpha-k-circle-outline
    min_value: 0.000
    max_value: 0.800
    step: 0.010
    mode: slider
    restore_value: true
    optimistic: true
    initial_value: 0.350
    web_server:
      sorting_group_id: oq_tuning_heat
    on_value:
      then:
        - climate.pid.set_control_parameters:
            id: oq_heating_curve_pid
            kp: !lambda "return id(heating_curve_pid_kp).state;"
            ki: !lambda "return id(heating_curve_pid_ki).state;"
            kd: !lambda "return id(heating_curve_pid_kd).state;"
        - climate.pid.reset_integral_term: oq_heating_curve_pid

  - platform: template
    id: heating_curve_pid_ki
    name: "Heating Curve PID Ki"
    icon: mdi:alpha-i-circle-outline
    min_value: 0.00000
    max_value: 0.00300
    step: 0.00010
    mode: slider
    restore_value: true
    optimistic: true
    initial_value: 0.00120
    web_server:
      sorting_group_id: oq_tuning_heat
    on_value:
      then:
        - climate.pid.set_control_parameters:
            id: oq_heating_curve_pid
            kp: !lambda "return id(heating_curve_pid_kp).state;"
            ki: !lambda "return id(heating_curve_pid_ki).state;"
            kd: !lambda "return id(heating_curve_pid_kd).state;"
        - climate.pid.reset_integral_term: oq_heating_curve_pid

  - platform: template
    id: heating_curve_pid_kd
    name: "Heating Curve PID Kd"
    icon: mdi:alpha-d-circle-outline
    min_value: 0.000
    max_value: 0.400
    step: 0.010
    mode: slider
    restore_value: true
    optimistic: true
    initial_value: 0.200
    web_server:
      sorting_group_id: oq_tuning_heat
    on_value:
      then:
        - climate.pid.set_control_parameters:
            id: oq_heating_curve_pid
            kp: !lambda "return id(heating_curve_pid_kp).state;"
            ki: !lambda "return id(heating_curve_pid_ki).state;"
            kd: !lambda "return id(heating_curve_pid_kd).state;"
        - climate.pid.reset_integral_term: oq_heating_curve_pid

  - platform: template
    id: curve_fallback_supply_temp
    name: "Curve Fallback Tsupply (No Outside Temp)"
    icon: mdi:thermometer-alert
    unit_of_measurement: "°C"
    min_value: 25
    max_value: 70
    step: 0.5
    restore_value: true
    optimistic: true
    initial_value: 40
    web_server:
      sorting_group_id: oq_tuning_heat

button:
  - platform: template
    id: reset_heating_curve_pid_integral
    name: "Reset Heating Curve PID integral"
    icon: mdi:restart
    entity_category: config
    web_server:
      sorting_group_id: oq_tuning_heat
    on_press:
      then:
        - climate.pid.reset_integral_term: oq_heating_curve_pid

# ----------------------------
# GLOBALS
# ----------------------------
globals:
  # Output of this strategy (0..20) - consumed by heat-control
  - id: oq_demand_raw
    type: int
    restore_value: false
    initial_value: '0'

  # Power House - requested house heat power (W)
  - id: oq_phouse_req_w
    type: float
    restore_value: false
    initial_value: '0.0'

  # Power House – interne ramp-limiter state
  - id: oq_phouse_last_w
    type: float
    restore_value: false
    initial_value: '0.0'

  - id: oq_phouse_last_ms
    type: uint32_t
    restore_value: false
    initial_value: '0'

  # Internal source (0..20) for heating-curve mode (PID -> demand)
  - id: oq_demand_curve
    type: int
    restore_value: false
    initial_value: '0'

  # Curve-mode on/off hysteresis state near zero-demand edge.
  - id: oq_curve_heat_request_active
    type: bool
    restore_value: false
    initial_value: 'false'

  # Curve outside-temperature EMA state.
  - id: oq_curve_outside_ema_c
    type: float
    restore_value: false
    initial_value: '0.0'
  - id: oq_curve_outside_ema_initialized
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: oq_curve_outside_ema_last_ms
    type: uint32_t
    restore_value: false
    initial_value: '0'

  - id: oq_heat_mode_code
    type: int
    restore_value: false
    initial_value: '0'  # 0=Power House, 1=Heating Curve

  # DEBUG-RUNTIME START: Power House adaptive comfort-bias diagnostics
  - id: oq_ph_comfort_bias_c
    type: float
    restore_value: false
    initial_value: '0.1'
  - id: oq_ph_room_error_avg_c
    type: float
    restore_value: false
    initial_value: '0.0'
  - id: oq_ph_room_error_avg_init
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: oq_ph_comfort_bias_last_ms
    type: uint32_t
    restore_value: false
    initial_value: '0'
  - id: oq_ph_room_target_effective_c
    type: float
    restore_value: false
    initial_value: '0.0'
  # DEBUG-RUNTIME END

# ----------------------------
# SENSORS - outdoor temperature aggregation + heating curve target
# ----------------------------
sensor:
  - platform: template
    id: outside_temp_hp_avg
    name: "Outside Temperature (Local aggregated)"
    icon: mdi:thermometer
    internal: false
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 1
    update_interval: 10s
    web_server:
      sorting_group_id: oq_temperatures
    lambda: |-
      const float hp1_outside_c = id(hp1_outside_temp).state;
      const float hp2_outside_c = id(hp2_outside_temp).state;

      const bool hp1_valid = !isnan(hp1_outside_c);
      const bool hp2_valid = !isnan(hp2_outside_c);

      if (hp1_valid && hp2_valid) return std::min(hp1_outside_c, hp2_outside_c);
      if (hp1_valid) return hp1_outside_c;
      if (hp2_valid) return hp2_outside_c;
      return NAN;

  - platform: template
    id: oq_curve_outside_temp_filtered
    name: "Outside Temperature (Curve filtered)"
    icon: mdi:thermometer-lines
    internal: true
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2
    update_interval: 10s
    lambda: |-
      const float outside_c = id(outside_temp_selected).state;
      if (isnan(outside_c)) {
        id(oq_curve_outside_ema_initialized) = false;
        id(oq_curve_outside_ema_last_ms) = 0;
        return NAN;
      }

      // Profile-based smoothing time constant:
      // Comfort = faster tracking, Stable = stronger smoothing.
      float tau_s = 1800.0f;  // Balanced default
      if (id(oq_curve_control_profile).has_state()) {
        const auto profile = id(oq_curve_control_profile).current_option();
        if (profile == "Comfort") tau_s = 900.0f;
        else if (profile == "Stable") tau_s = 3600.0f;
      }

      const uint32_t now_ms = (uint32_t) millis();
      if (!id(oq_curve_outside_ema_initialized) ||
          id(oq_curve_outside_ema_last_ms) == 0 ||
          now_ms <= id(oq_curve_outside_ema_last_ms)) {
        id(oq_curve_outside_ema_c) = outside_c;
        id(oq_curve_outside_ema_initialized) = true;
        id(oq_curve_outside_ema_last_ms) = now_ms;
        return outside_c;
      }

      const float dt_s = (now_ms - id(oq_curve_outside_ema_last_ms)) / 1000.0f;
      float alpha = dt_s / (tau_s + dt_s);
      if (alpha < 0.0f) alpha = 0.0f;
      if (alpha > 1.0f) alpha = 1.0f;

      float ema_c = id(oq_curve_outside_ema_c);
      if (isnan(ema_c)) ema_c = outside_c;
      ema_c += alpha * (outside_c - ema_c);

      id(oq_curve_outside_ema_c) = ema_c;
      id(oq_curve_outside_ema_last_ms) = now_ms;
      return ema_c;

  - platform: template
    id: oq_system_supply_temp
    name: "System Supply Temp (abstraction)"
    icon: mdi:water-thermometer
    internal: true
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 1
    update_interval: 5s
    web_server:
      sorting_group_id: oq_temperatures
    lambda: |-
      // Prefer: selected supply source (water_supply_temp_selected). Fallback: HP2 / HP1 water_out.
      float supply_c = NAN;
      if (id(water_supply_temp_selected).has_state()) {
        const float selected_supply_c = id(water_supply_temp_selected).state;
        if (!isnan(selected_supply_c)) supply_c = selected_supply_c;
      }
      if (isnan(supply_c)) {
        const float hp2_out_c = id(hp2_water_out_temp).state;
        if (!isnan(hp2_out_c)) supply_c = hp2_out_c;
      }
      if (isnan(supply_c)) {
        const float hp1_out_c = id(hp1_water_out_temp).state;
        if (!isnan(hp1_out_c)) supply_c = hp1_out_c;
      }
      return supply_c;

  - platform: template
    id: oq_phouse_house_w
    name: "Power House – P_house"
    icon: mdi:home-lightning-bolt
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    accuracy_decimals: 0
    update_interval: 5s
    web_server:
      sorting_group_id: oq_overview
    lambda: |-
      const float Tout = id(outside_temp_selected).state;
      const float Tc = id(house_cold_temp_c).state;
      const float T0 = id(house_zero_power_temp_c).state;
      const float Pr = id(house_rated_power_w).state;

      if (isnan(Tout) || isnan(Tc) || isnan(T0) || isnan(Pr)) return NAN;
      if (T0 <= Tc + ${oq_temp_guard_delta_c}f) return NAN;

      float x = (T0 - Tout) / (T0 - Tc);
      if (x < 0.0f) x = 0.0f;
      if (x > 1.0f) x = 1.0f;
      return Pr * x;

  - platform: template
    id: oq_phouse_req_w_sensor
    name: "Power House – P_req"
    icon: mdi:flash
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    accuracy_decimals: 0
    update_interval: 5s
    web_server:
      sorting_group_id: oq_overview
    lambda: |-
      return id(oq_phouse_req_w);

  - platform: template
    id: oq_supply_target_temp
    name: "Heating Curve Supply Target"
    icon: mdi:target
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 1
    update_interval: 10s
    web_server:
      sorting_group_id: oq_temperatures
    on_value:
      then:
        - lambda: |-
            // Sync heating curve setpoint to Heating Curve PID
            if (isnan(x)) return;
            float min_change_c = 0.10f;  // Balanced default
            if (id(oq_curve_control_profile).has_state()) {
              const auto profile = id(oq_curve_control_profile).current_option();
              if (profile == "Comfort") min_change_c = 0.05f;
              else if (profile == "Stable") min_change_c = 0.20f;
            }
            const float current_target_c = id(oq_heating_curve_pid).target_temperature;
            if (isnan(current_target_c) || fabsf(current_target_c - x) >= min_change_c) {
              auto call = id(oq_heating_curve_pid).make_call();
              call.set_mode(CLIMATE_MODE_HEAT);
              call.set_target_temperature(x);
              call.perform();
            }
    lambda: |-
      const float outside_c = id(oq_curve_outside_temp_filtered).state;
      float target_c = id(curve_fallback_supply_temp).state;

      struct Point { float outside_c; float target_c; };
      const Point points[6] = {
        {-20.0f, id(curve_tsupply_m20).state},
        {-10.0f, id(curve_tsupply_m10).state},
        {  0.0f, id(curve_tsupply_0).state},
        {  5.0f, id(curve_tsupply_5).state},
        { 10.0f, id(curve_tsupply_10).state},
        { 15.0f, id(curve_tsupply_15).state}
      };

      if (!isnan(outside_c)) {
        if (outside_c <= -20.0f) target_c = points[0].target_c;
        else if (outside_c >= 15.0f) target_c = points[5].target_c;
        else {
          for (int i = 0; i < 5; i++) {
            if (outside_c >= points[i].outside_c && outside_c <= points[i + 1].outside_c) {
              const float segment = (outside_c - points[i].outside_c) / (points[i + 1].outside_c - points[i].outside_c);
              target_c = points[i].target_c + segment * (points[i + 1].target_c - points[i].target_c);
              break;
            }
          }
        }
      }

      // Profile-based target quantization keeps supply target calm at low load.
      float quant_step_c = 0.5f;  // Balanced default
      if (id(oq_curve_control_profile).has_state()) {
        const auto profile = id(oq_curve_control_profile).current_option();
        if (profile == "Comfort") quant_step_c = 0.25f;
        else if (profile == "Stable") quant_step_c = 1.0f;
      }
      if (!isnan(target_c) && quant_step_c > 0.0f) {
        target_c = roundf(target_c / quant_step_c) * quant_step_c;
      }
      return target_c;

  # Diagnostics
  - platform: template
    id: oq_demand_curve_sensor
    name: "Demand Curve (raw)"
    icon: mdi:counter
    unit_of_measurement: "step"
    state_class: measurement
    accuracy_decimals: 0
    update_interval: 5s
    web_server:
      sorting_group_id: oq_diagnostics
    lambda: |-
      return (float) id(oq_demand_curve);

  # DEBUG-RUNTIME START: Power House adaptive comfort-bias diagnostics
  - platform: template
    id: oq_phouse_room_error_avg_c_sensor
    name: "Power House room error avg"
    icon: mdi:chart-timeline-variant
    unit_of_measurement: "°C"
    state_class: measurement
    accuracy_decimals: 3
    update_interval: 5s
    entity_category: diagnostic
    web_server:
      sorting_group_id: oq_diagnostics
    lambda: |-
      return id(oq_ph_room_error_avg_c);

  - platform: template
    id: oq_phouse_comfort_bias_c_sensor
    name: "Power House comfort bias"
    icon: mdi:thermometer-plus
    unit_of_measurement: "°C"
    state_class: measurement
    accuracy_decimals: 3
    update_interval: 5s
    entity_category: diagnostic
    web_server:
      sorting_group_id: oq_diagnostics
    lambda: |-
      return id(oq_ph_comfort_bias_c);

  - platform: template
    id: oq_phouse_room_target_effective_c_sensor
    name: "Power House effective room target"
    icon: mdi:target
    unit_of_measurement: "°C"
    state_class: measurement
    accuracy_decimals: 2
    update_interval: 5s
    entity_category: diagnostic
    web_server:
      sorting_group_id: oq_diagnostics
    lambda: |-
      return id(oq_ph_room_target_effective_c);
  # DEBUG-RUNTIME END

# ----------------------------
# STATUS
# ----------------------------
text_sensor:
  - platform: template
    id: heating_strategy_status
    name: "Heating Strategy"
    icon: mdi:state-machine
    update_interval: 5s
    web_server:
      sorting_group_id: oq_overview
    lambda: |-
      return std::string(id(oq_heat_control_mode).current_option().c_str());

# ----------------------------
# TEMPERATURE CONTROLLER (PID climate)
# ----------------------------
climate:
  - platform: pid
    id: oq_heating_curve_pid
    name: "Heating Curve PID"
    icon: mdi:thermostat
    sensor: oq_system_supply_temp
    default_target_temperature: 35 °C   # is synchronized with oq_supply_target_temp
    heat_output: heating_curve_pid_out
    control_parameters:
      kp: 0.350
      ki: 0.00120
      kd: 0.200
      max_integral: 3.0
      min_integral: -3.0
    deadband_parameters:
      threshold_low: -0.20
      threshold_high: 0.20
      deadband_output_averaging_samples: 6
    visual:
      min_temperature: 20
      max_temperature: 70
    web_server:
      sorting_group_id: oq_tuning_heat

# ----------------------------
# PID OUTPUT ADAPTER
# ----------------------------
output:
  - platform: template
    id: heating_curve_pid_out
    type: float
    write_action:
      - lambda: |-
          // Guardrail: only let PID-path write curve demand in heating-curve mode.
          // In Power House mode, this output is diagnostic-only and must remain 0.
          if (id(oq_heat_mode_code) != 1) {
            id(oq_demand_curve) = 0;
            id(oq_curve_heat_request_active) = false;
            return;
          }

          // PID output is 0..1 (heat_output). Map to demand steps 0..20.
          const int demand_max = (int) ${oq_strategy_demand_max_f};
          if (isnan(state)) {
            id(oq_demand_curve) = 0;
            id(oq_curve_heat_request_active) = false;
            return;
          }

          int d = (int) lroundf(state * ${oq_strategy_demand_max_f});
          if (d < 0) d = 0;
          if (d > demand_max) d = demand_max;

          // Start/stop hysteresis near the zero-demand edge:
          // - Start heating when supply is below (SP - start_delta)
          // - Stop heating when supply is above (SP + stop_delta)
          // This replaces the previous deadband/off-hold pair with a deterministic gate.
          const float spw = id(oq_supply_target_temp).state;
          const float pv = id(oq_system_supply_temp).state;
          if (isnan(spw) || isnan(pv)) {
            id(oq_curve_heat_request_active) = false;
            id(oq_demand_curve) = 0;
            return;
          }

          float start_delta_c = 0.45f;  // Balanced default
          float stop_delta_c = 0.75f;   // Balanced default
          if (id(oq_curve_control_profile).has_state()) {
            const auto profile = id(oq_curve_control_profile).current_option();
            if (profile == "Comfort") {
              start_delta_c = 0.30f;
              stop_delta_c = 0.55f;
            } else if (profile == "Stable") {
              start_delta_c = 0.65f;
              stop_delta_c = 1.00f;
            }
          }
          if (stop_delta_c < start_delta_c + 0.10f) stop_delta_c = start_delta_c + 0.10f;

          bool heat_request_active = id(oq_curve_heat_request_active);
          if (heat_request_active) {
            if (pv >= (spw + stop_delta_c)) heat_request_active = false;
          } else {
            if (pv <= (spw - start_delta_c)) heat_request_active = true;
          }

          id(oq_curve_heat_request_active) = heat_request_active;
          if (!heat_request_active) {
            d = 0;
          } else if (d < 1) {
            d = 1;
          }

          id(oq_demand_curve) = d;

# ----------------------------
# INTERVAL (5s)
#   * Power House: computes P_req (W) + compatible demand (0..20)
#   * Water temperature control: runs Heating Curve PID and provides demand (0..20)
# ----------------------------
interval:
  - interval: ${oq_strategy_loop_s}s
    then:
      - lambda: |-
          // Select mode via stable option index (0=Power House, 1=Heating Curve)
          const int heat_mode_code = id(oq_heat_control_mode).active_index().value_or(0) == 1 ? 1 : 0;
          id(oq_heat_mode_code) = heat_mode_code;
          const int demand_max = (int) ${oq_strategy_demand_max_f};
          constexpr float seconds_per_minute = 60.0f;

          // Helper: clamp
          auto clampf = [&](float v, float lo, float hi)->float {
            if (v < lo) return lo;
            if (v > hi) return hi;
            return v;
          };
          auto clamp_demand = [&](int demand)->int {
            if (demand < 0) return 0;
            if (demand > demand_max) return demand_max;
            return demand;
          };

          if (heat_mode_code == 1) {
            // ------------------------------------------------------------
            // WATER TEMP MODE
            // - Heating Curve PID: PV = oq_system_supply_temp, SP = oq_supply_target_temp
            // - PID output -> oq_demand_curve via heating_curve_pid_out
            // - Strategy output: oq_demand_raw = oq_demand_curve
            // ------------------------------------------------------------
            const float spw = id(oq_supply_target_temp).state;
            const float pv  = id(oq_system_supply_temp).state;

            if (isnan(spw) || isnan(pv)) {
              // Fail-safe: no valid PV/SP => no heat demand
              id(oq_demand_curve) = 0;
              id(oq_curve_heat_request_active) = false;
              // Integral reset is handled explicitly in the if/then block below.
            } else {
              const float cur2 = id(oq_heating_curve_pid).target_temperature;
              if (isnan(cur2) || fabsf(cur2 - spw) >= 0.10f) {
                auto c2 = id(oq_heating_curve_pid).make_call();

                // Set mode only when needed (fewer unnecessary calls)
                if (id(oq_heating_curve_pid).mode != CLIMATE_MODE_HEAT) {
                  c2.set_mode(CLIMATE_MODE_HEAT);
                }

                c2.set_target_temperature(spw);
                c2.perform();
              }
            }

            const int d_out = clamp_demand(id(oq_demand_curve));
            id(oq_demand_raw) = d_out;

            // Power request (W) is also maintained in this mode (for deficit/CM3):
            // Approximation: map demand (0..20) linearly to house_rated_power_w.
            // This keeps deficit detection/CM3 behavior consistent between Power House and heating-curve mode.
            const float Pr_est = id(house_rated_power_w).state;
            float P_req_est = 0.0f;
            if (!isnan(Pr_est) && Pr_est > 0.0f) {
              P_req_est = (Pr_est * ((float)d_out / ${oq_strategy_demand_max_f}));
              if (P_req_est < 0.0f) P_req_est = 0.0f;
              if (P_req_est > Pr_est) P_req_est = Pr_est;
            }
            id(oq_phouse_req_w) = P_req_est;

            // Ramp state: force re-init when switching back to Power House
            id(oq_phouse_last_w) = P_req_est;
            id(oq_phouse_last_ms) = 0;
            id(oq_ph_comfort_bias_last_ms) = 0;
            id(oq_ph_room_target_effective_c) = id(room_setpoint_selected).state;
          } else {
            // ------------------------------------------------------------
            // POWER HOUSE MODE
            // - Feedforward P_house(Tout) + room error correctie -> P_req_total (W)
            // - Ramp limiter in W/min
            // - Compat: oq_demand_raw = round(20 * P_req / house_rated_power)
            // ------------------------------------------------------------
            if (id(oq_heating_curve_pid).mode != CLIMATE_MODE_OFF) {
              auto c0 = id(oq_heating_curve_pid).make_call();
              c0.set_mode(CLIMATE_MODE_OFF);
              c0.perform();
            }
            id(oq_curve_heat_request_active) = false;
            const float Tout = id(outside_temp_selected).state;
            const float Tc   = id(house_cold_temp_c).state;
            const float T0   = id(house_zero_power_temp_c).state;
            const float Pr   = id(house_rated_power_w).state;

            const float Tr   = id(room_temp_selected).state;
            const float Trsp = id(room_setpoint_selected).state;

            if (isnan(Tout) || isnan(Tc) || isnan(T0) || isnan(Pr) || (Pr <= 0.0f) || isnan(Tr) || isnan(Trsp) || (T0 <= Tc + ${oq_temp_guard_delta_c}f)) {
              id(oq_phouse_req_w) = 0.0f;
              id(oq_demand_raw) = 0;
              return;
            }

            // P_house
            float x = (T0 - Tout) / (T0 - Tc);
            x = clampf(x, 0.0f, 1.0f);
            const float P_house = Pr * x;

            // DEBUG-RUNTIME: adaptive comfort-bias governor for warm-leaning behavior.
            const uint32_t now_ms = (uint32_t) millis();
            const float bias_base_cfg = clampf(id(ph_comfort_bias_base_c).state, 0.0f, 0.5f);
            const float bias_max_cfg = clampf(id(ph_comfort_bias_max_c).state, bias_base_cfg, 0.5f);
            const float bias_up_cfg_per_s = clampf(id(ph_comfort_bias_up_c_per_h).state, 0.0f, 0.5f) / 3600.0f;
            const float bias_down_cfg_per_s = clampf(id(ph_comfort_bias_down_c_per_h).state, 0.0f, 1.0f) / 3600.0f;
            const float tau_s = clampf(id(ph_room_error_avg_tau_min).state * seconds_per_minute, 60.0f, 7200.0f);
            float bias_c = id(oq_ph_comfort_bias_c);
            if (isnan(bias_c)) bias_c = bias_base_cfg;
            bias_c = clampf(bias_c, bias_base_cfg, bias_max_cfg);

            const uint32_t bias_last_ms = id(oq_ph_comfort_bias_last_ms);
            const float dt_bias_s = (bias_last_ms > 0 && now_ms >= bias_last_ms) ? ((now_ms - bias_last_ms) / 1000.0f) : 0.0f;
            const float room_err_now_c = Tr - Trsp;
            float room_err_avg_c = id(oq_ph_room_error_avg_c);
            if (!id(oq_ph_room_error_avg_init) || isnan(room_err_avg_c)) {
              room_err_avg_c = room_err_now_c;
              id(oq_ph_room_error_avg_init) = true;
            } else if (dt_bias_s > 0.0f) {
              const float alpha = clampf(dt_bias_s / (tau_s + dt_bias_s), 0.0f, 1.0f);
              room_err_avg_c += alpha * (room_err_now_c - room_err_avg_c);
            }

            constexpr float cold_err_on_c = -0.05f;
            constexpr float warm_err_on_c = 0.20f;
            if (dt_bias_s > 0.0f) {
              if (room_err_avg_c < cold_err_on_c) {
                bias_c += bias_up_cfg_per_s * dt_bias_s;
              } else if (room_err_avg_c > warm_err_on_c) {
                bias_c -= bias_down_cfg_per_s * dt_bias_s;
              }
            }
            bias_c = clampf(bias_c, bias_base_cfg, bias_max_cfg);
            id(oq_ph_comfort_bias_c) = bias_c;
            id(oq_ph_room_error_avg_c) = room_err_avg_c;
            id(oq_ph_comfort_bias_last_ms) = now_ms;

            const float Trsp_eff = Trsp + bias_c;
            id(oq_ph_room_target_effective_c) = Trsp_eff;

            // Room correction
            // Asymmetric comfort band around room setpoint:
            // - below band: lower edge where extra correction starts
            // - above band: upper edge where negative correction starts
            // Inside this comfort band, room correction is zero.
            // Hard cap: upper edge never exceeds (setpoint + comfort bias max).
            const float comfort_below = clampf(id(ph_comfort_band_below_c).state, 0.0f, 2.0f);
            const float comfort_above = clampf(id(ph_comfort_band_above_c).state, 0.0f, 2.0f);
            const float Tr_low = Trsp_eff - comfort_below;
            const float Tr_high_uncapped = Trsp_eff + comfort_above;
            const float Tr_high = std::min(Tr_high_uncapped, Trsp + bias_max_cfg);

            float e = 0.0f; // K
            if (Tr < Tr_low) {
              e = Tr_low - Tr;
            } else if (Tr > Tr_high) {
              e = Tr_high - Tr;
            }

            const float db = id(ph_deadband_k).state;
            if (!isnan(db) && db > 0.0f && fabsf(e) < db) e = 0.0f;

            const float kp = id(ph_kp_w_per_k).state;
            float P_raw = P_house + kp * e;
            P_raw = clampf(P_raw, 0.0f, Pr);

            // Ramp limiting
            uint32_t last = id(oq_phouse_last_ms);
            float lastw = id(oq_phouse_last_w);
            if (last == 0) { last = now_ms; lastw = P_raw; }

            const float dt_s = (now_ms >= last) ? ((now_ms - last) / 1000.0f) : 0.0f;
            const float up = id(ph_ramp_up_w_per_min).state / seconds_per_minute;     // W/s
            const float dn = id(ph_ramp_down_w_per_min).state / seconds_per_minute;   // W/s

            float P_limited = P_raw;
            if (dt_s > 0.0f) {
              if (P_raw > lastw && up > 0) {
                P_limited = std::min(P_raw, lastw + up * dt_s);
              } else if (P_raw < lastw && dn > 0) {
                P_limited = std::max(P_raw, lastw - dn * dt_s);
              }
            }

            id(oq_phouse_req_w) = P_limited;
            id(oq_phouse_last_w) = P_limited;
            id(oq_phouse_last_ms) = now_ms;

            // Compat demand 0..20
            int d = (int) lroundf(${oq_strategy_demand_max_f} * (P_limited / Pr));
            id(oq_demand_raw) = clamp_demand(d);

            // In power house mode is curve demand diagnostisch 0
            id(oq_demand_curve) = 0;
          }
      - if:
          condition:
            lambda: |-
              // Anti-windup:
              // - if SP/PV drops out in heating-curve mode, reset integral term
              // - if hysteresis gate is OFF, clear integral to avoid continued push
              if (id(oq_heat_mode_code) != 1) return false;
              const float spw = id(oq_supply_target_temp).state;
              const float pv  = id(oq_system_supply_temp).state;
              return isnan(spw) || isnan(pv) || !id(oq_curve_heat_request_active);
          then:
            - climate.pid.reset_integral_term: oq_heating_curve_pid
