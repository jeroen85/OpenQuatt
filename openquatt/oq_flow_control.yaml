# ==============================================================================
# OpenQuatt â€“ Flow Control
# ==============================================================================
#
# Goal:
#   Regulates and monitors water flow; hydraulic safety takes priority over heat production.
#
# Role in architecture:
#   Owns non-CM0 pump iPWM behavior, runs PI control, and provides flow diagnostics.
#
# What this package DOES do:
#   - Uses measured/filtered flow (flow_rate_selected) for PI control
#   - Controls pump PWM to reach target flow
#   - Publishes flow status and mismatch diagnostics for supervisory/operations
#
# What this package DOES NOT do:
#   - Does not control compressor levels
#   - Does not determine Control Mode (supervisory does)
#   - Does not decide on boiler auxiliary heating
#
# Key assumptions:
#   - Flow sensor/flow_rate_selected is available and correctly scaled (L/h)
#   - Pump output is correctly configured for PWM
#
# Interaction with Control Modes:
#   - Active in CM1/CM2/CM3 (AUTO=PI, MANUAL=fixed iPWM)
#   - CM0: early return (supervisory owns pump state in idle)
#   - CM98: fixed frost PWM path
#
# Safety / fail-safe:
#   - Hydraulic safety: at insufficient flow, heat production must stop (via CM1)
#   - PI is tuned for stability to avoid oscillation
#
# ==============================================================================

# ----------------------------
# TUNING INPUTS
# ----------------------------
number:
  - platform: template
    id: oq_flow_setpoint_lph
    name: "Flow Setpoint"
    icon: mdi:waves-arrow-right
    unit_of_measurement: "L/h"
    mode: slider
    web_server:
      sorting_group_id: oq_control
    min_value: 0
    max_value: 1500
    step: 10
    restore_value: true
    optimistic: true
    initial_value: 800

  - platform: template
    id: oq_flow_manual_pwm
    name: "Manual iPWM"
    icon: mdi:fan
    unit_of_measurement: "iPWM"
    mode: slider
    min_value: 50
    max_value: 850
    step: 1
    initial_value: 400
    restore_value: true
    optimistic: true
    web_server:
      sorting_group_id: oq_control

  - platform: template
    id: oq_flow_frost_pwm
    name: "Frost Circulation iPWM"
    icon: mdi:snowflake
    unit_of_measurement: "iPWM"
    mode: slider
    web_server:
      sorting_group_id: oq_tuning_flow
    min_value: 50
    max_value: 850
    step: 10
    restore_value: true
    optimistic: true
    initial_value: 800

  - platform: template
    id: oq_flow_auto_start_pwm
    name: "Flow AUTO start iPWM"
    icon: mdi:rocket-launch-outline
    unit_of_measurement: "iPWM"
    mode: slider
    web_server:
      sorting_group_id: oq_tuning_flow
    min_value: 50
    max_value: 850
    step: 1
    restore_value: true
    optimistic: true
    initial_value: 440
    entity_category: config

  - platform: template
    id: oq_flow_kp
    name: "Flow PI Kp"
    icon: mdi:alpha-k-circle-outline
    mode: slider
    web_server:
      sorting_group_id: oq_tuning_flow
    min_value: ${oq_flow_kp_min}
    max_value: ${oq_flow_kp_max}
    step: 0.001
    restore_value: true
    optimistic: true
    # Default increased for more robust control in the current hydraulic setup.
    initial_value: 0.03

  - platform: template
    id: oq_flow_ki
    name: "Flow PI Ki"
    icon: mdi:alpha-i-circle-outline
    mode: slider
    web_server:
      sorting_group_id: oq_tuning_flow
    min_value: ${oq_flow_ki_min}
    max_value: ${oq_flow_ki_max}
    step: 0.0001
    restore_value: true
    optimistic: true
    initial_value: 0.0008

# ----------------------------
# SENSORS
# ----------------------------
sensor:
  # Average flow HP1/HP2
  - platform: template
    id: flow_rate_hp_avg
    name: "Flow average (local)"
    icon: mdi:waves
    unit_of_measurement: "L/h"
    device_class: volume_flow_rate
    state_class: measurement
    web_server:
      sorting_group_id: oq_hydraulics
    accuracy_decimals: 0
    update_interval: 1s
    lambda: |-
      float f1 = id(hp1_flow).state;
      float f2 = id(hp2_flow).state;

      const bool v1 = !isnan(f1);
      const bool v2 = !isnan(f2);
      const float thr = ${oq_flow_mismatch_threshold_lph};

      if (v1 && v2) {
        const float diff = fabsf(f1 - f2);

        // In series, f1 and f2 should be (almost) equal.
        // If they diverge significantly, treat it as a measurement/comms issue and choose a plausible value.
        if (diff > thr) {
          // Heuristic: a sensor stuck at 0 is more common than one reading too high.
          // Therefore use the larger value to avoid underestimation and unnecessary PI overreaction.
          return fmaxf(f1, f2);
        }

        // Normal case: averaging is fine (noise reduction)
        return (f1 + f2) / 2.0f;
      }

      // If one sensor is NaN (comms issue), use the other.
      if (v1) return f1;
      if (v2) return f2;

      // Only when both are NaN: no valid flow.
      return NAN;

binary_sensor:
  - platform: template
    id: oq_flow_mismatch
    name: "Flow mismatch (HP1 vs HP2)"
    icon: mdi:alert-circle-outline
    device_class: problem
    entity_category: diagnostic
    web_server:
      sorting_group_id: oq_diagnostics
    lambda: |-
      static bool state = false;
      static bool mismatch_timer_running = false;
      static uint32_t mismatch_start_ms = 0;

      float f1 = id(hp1_flow).state;
      float f2 = id(hp2_flow).state;

      // Evaluate only when both are valid; otherwise reset indication.
      if (isnan(f1) || isnan(f2)) {
        state = false;
        mismatch_timer_running = false;
        return false;
      }

      const float diff = fabsf(f1 - f2);

      const float thr = ${oq_flow_mismatch_threshold_lph};

      const float h = ${oq_flow_mismatch_hyst_lph};
      const float on_thr  = thr;
      const float off_thr = fmaxf(0.0f, thr - h);
      const uint32_t now = millis();
      const uint32_t hold_ms = 30000;

      if (!state) {
        if (diff > on_thr) {
          if (!mismatch_timer_running) {
            mismatch_timer_running = true;
            mismatch_start_ms = now;
          }
          if ((uint32_t)(now - mismatch_start_ms) >= hold_ms) {
            state = true;
            mismatch_timer_running = false;
          }
        } else {
          mismatch_timer_running = false;
        }
      } else {
        if (diff < off_thr) state = false;
      }
      return state;

# ----------------------------
# CONFIG: Flow Control Mode
#   - Flow Setpoint : PI controls flow to oq_flow_setpoint_lph
#   - Manual PWM    : fixed iPWM from oq_flow_manual_pwm (no PI)
# ----------------------------
select:
  - platform: template
    id: oq_flow_control_mode
    name: "Flow Control Mode"
    icon: mdi:tune-variant
    options:
      - Flow Setpoint
      - Manual PWM
    initial_option: Flow Setpoint
    restore_value: true
    optimistic: true
    web_server:
      sorting_group_id: oq_control

# ----------------------------
# STATUS (CM0/CM98/AUTO/MANUAL)
# ----------------------------
text_sensor:
  - platform: template
    id: oq_flow_mode
    name: "Flow Mode"
    icon: mdi:state-machine
    web_server:
      sorting_group_id: oq_hydraulics

  - platform: template
    id: oq_flow_debug_state
    name: "Flow Debug State"
    icon: mdi:bug-outline
    entity_category: diagnostic
    disabled_by_default: true
    update_interval: never
    web_server:
      sorting_group_id: oq_diagnostics

# ----------------------------
# INTERNAL STATE (PI)
# ----------------------------
globals:
  - id: oq_flow_i
    type: float
    restore_value: false
    initial_value: '0.0'
  - id: oq_flow_last_pwm
    type: int
    restore_value: false
    initial_value: '850'
  - id: oq_flow_last_mode
    type: int
    restore_value: false
    initial_value: '0'   # 0=AUTO, 1=MANUAL, 2=FROST
  - id: oq_flow_last_good_pwm
    type: int
    restore_value: true
    initial_value: "440"
  - id: oq_flow_control_mode_code
    type: int
    restore_value: false
    initial_value: '0'   # 0=AUTO, 1=MANUAL
  - id: oq_flow_autotune_active
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: oq_flow_autotune_pwm
    type: int
    restore_value: false
    initial_value: '850'

# ----------------------------
# MAIN LOOP (5s): PI + mode handling
# ----------------------------
interval:
  - interval: ${oq_flow_loop_s}s
    then:
      - lambda: |-
          // ============================================================================
          // FLOW CONTROL EXECUTION MODEL
          //
          // Ownership:
          // - Supervisory owns pump enable mode (On/Off) and CM selection.
          // - This loop owns pump iPWM for all non-CM0 modes.
          //
          // Priority (highest -> lowest):
          // 1) CM0 early return (no writes from this loop)
          // 2) AUTOTUNE override (CM1 only)
          // 3) MANUAL / FROST fixed iPWM
          // 4) AUTO PI path (with startup-hold + failsafe)
          //
          // iPWM semantics:
          // - 50..850 = pump running (lower means harder)
          // - 1000 is reserved for CM0 stop policy in supervisory
          // ============================================================================
          const float dt = ${oq_flow_loop_s};   // seconds per tick
          static std::string last_mode = "";

          static bool was_cm0 = true;

          // One central hold time for all start transitions
          constexpr int STARTUP_HOLD_S = 10;     // seconds
          const int STARTUP_HOLD_TICKS = (STARTUP_HOLD_S <= 0) ? 0 : (int) roundf((float)STARTUP_HOLD_S / dt);
          // Note: with interval tick dt, startup_hold counts ticks of "AUTO(starting)".

          static int  startup_hold = 0;         // number of ticks in "AUTO(starting)"
          static int  stable_cnt = 0;           // stability counter for last_good_pwm
          static bool pi_failsafe = false;       // latched per tick

          // Setpoint ramp state
          static float sp_f = NAN;

          // Explicit execution mode keeps the control flow readable and makes
          // status publishing deterministic.
          enum FlowExecMode {
            FLOW_MODE_CM0 = 0,
            FLOW_MODE_AUTOTUNE = 1,
            FLOW_MODE_MANUAL = 2,
            FLOW_MODE_FROST = 3,
            FLOW_MODE_AUTO_STARTING = 4,
            FLOW_MODE_AUTO = 5,
            FLOW_MODE_AUTO_FAILSAFE = 6
          };

          // --- helpers ---
          auto clamp_iPWM = [](int value) -> int {
            constexpr int kMinIpwm = 50;
            constexpr int kMaxIpwm = 850;
            if (value < kMinIpwm) return kMinIpwm;
            if (value > kMaxIpwm) return kMaxIpwm;
            return value;
          };
          auto write_pump_pwm_if_changed = [](auto *num, int value) {
            if (num == nullptr) return;
            const float cur = num->state;
            if (isnan(cur) || fabsf(cur - value) > 1.0f) {
              auto c = num->make_call();
              c.set_value(value);
              c.perform();
            }
          };
          // Common AUTO-entry init used for CM0->* and MANUAL->AUTO edges.
          auto start_auto_transition = [&](const char *tag) {
            int fallback = (int) roundf(id(oq_flow_auto_start_pwm).state);
            fallback = clamp_iPWM(fallback);

            int start_pwm = (int) id(oq_flow_last_good_pwm);
            if (start_pwm < 50 || start_pwm > 850) start_pwm = fallback;

            ESP_LOGI("flow", "AUTO start(%s): iPWM=%d (last_good=%d fallback=%d, hold %ds, I-freeze)",
                     tag, start_pwm, (int)id(oq_flow_last_good_pwm), fallback, STARTUP_HOLD_S);

            id(oq_flow_last_pwm) = start_pwm;
            id(oq_flow_i) = 0.0f;
            startup_hold = STARTUP_HOLD_TICKS;
            sp_f = NAN;
            stable_cnt = 0;
          };
          // Compact one-line diagnostics to compare mode decisions over time.
          auto publish_debug = [&](FlowExecMode mode, int cm_code, int pwm) {
            static std::string last_debug = "";
            const char *mode_s = "AUTO";
            switch (mode) {
              case FLOW_MODE_CM0: mode_s = "CM0"; break;
              case FLOW_MODE_AUTOTUNE: mode_s = "AUTOTUNE"; break;
              case FLOW_MODE_MANUAL: mode_s = "MANUAL"; break;
              case FLOW_MODE_FROST: mode_s = "CM98"; break;
              case FLOW_MODE_AUTO_STARTING: mode_s = "AUTO_STARTING"; break;
              case FLOW_MODE_AUTO_FAILSAFE: mode_s = "AUTO_FAILSAFE"; break;
              default: mode_s = "AUTO"; break;
            }
            char buf[160];
            snprintf(buf, sizeof(buf), "mode=%s cm=%d manual=%d failsafe=%d hold=%d pwm=%d",
                     mode_s, cm_code, (int)(id(oq_flow_control_mode_code) == 1), (int)pi_failsafe, startup_hold, pwm);
            const std::string s(buf);
            if (s != last_debug) {
              id(oq_flow_debug_state).publish_state(s.c_str());
              last_debug = s;
            }
          };
          // AUTO PI path only: setpoint ramp, PI, startup-hold, and last_good tracking.
          auto run_auto_pi = [&](int pwm_seed) -> int {
            int pwm_local = pwm_seed;
            float sp_target = id(oq_flow_setpoint_lph).state;
            float pv = id(flow_rate_selected).state;

            // Treat 0 L/h as a valid measurement (no-flow state), not as sensor failure.
            // This prevents an AUTO(start) deadlock where PI would stay in failsafe and never build flow.
            const bool flow_signal_valid = !isnan(pv);
            pi_failsafe = (isnan(sp_target) || sp_target <= 0.0f || !flow_signal_valid);

            if (pi_failsafe) {
              constexpr int kFailsafeIpwm = 850;
              pwm_local = kFailsafeIpwm;
              ESP_LOGW("flow", "Flow PI failsafe: sp=%0.1f pv=%0.1f -> forcing iPWM=%d", sp_target, pv, kFailsafeIpwm);
              id(oq_flow_i) = 0.0f;
              stable_cnt = 0;
              sp_f = NAN;
              return pwm_local;
            }

            const float sp_ramp_up = 25.0f;   // L/h per second up
            const float sp_ramp_dn = 15.0f;   // L/h per second down
            if (isnan(sp_f)) {
              // On AUTO entry, start ramp from measured PV to avoid a large startup kick.
              sp_f = flow_signal_valid ? pv : sp_target;
            }

            float d = sp_target - sp_f;
            float max_step = ((d >= 0.0f) ? sp_ramp_up : sp_ramp_dn) * dt;
            if (d >  max_step) d =  max_step;
            if (d < -max_step) d = -max_step;
            sp_f += d;

            float e = sp_f - pv;  // positive => more flow needed

            constexpr float deadband_lph = 10.0f;
            if (fabsf(e) < deadband_lph) e = 0.0f;

            const float kp = id(oq_flow_kp).state;
            const float ki = id(oq_flow_ki).state;

            const bool in_startup_hold = (startup_hold > 0);
            if (!in_startup_hold) {
              id(oq_flow_i) += e * dt;
              id(oq_flow_i) = fmaxf(-6000.0f, fminf(6000.0f, id(oq_flow_i)));
            } else if (flow_signal_valid) {
              startup_hold--;
            }

            float u = kp * e + ki * id(oq_flow_i);
            // Asymmetric action limit: during startup hold we reduce "pump harder"
            // authority to avoid overshoot from delayed flow feedback.
            const float u_up_s = in_startup_hold ? 3.0f : 12.0f;
            const float u_down_s = in_startup_hold ? 10.0f : 8.0f;
            const float u_up = u_up_s * dt;
            const float u_down = u_down_s * dt;
            const float u_lim = (e >= 0.0f) ? u_up : u_down;
            u = fmaxf(-u_lim, fminf(u_lim, u));

            pwm_local = (int) roundf((float)pwm_local - u);
            pwm_local = clamp_iPWM(pwm_local);

            const float stable_err_lph = 15.0f;
            constexpr int stable_time_s = 60;
            const int stable_time_ticks = (stable_time_s <= 0) ? 0 : (int) roundf((float)stable_time_s / dt);
            constexpr int good_pwm_step = 10;

            if (startup_hold <= 0 && !pi_failsafe) {
              const float e_target = sp_target - pv;
              if (fabsf(e_target) < stable_err_lph) {
                stable_cnt++;
              } else {
                stable_cnt = 0;
              }

              if (stable_cnt >= stable_time_ticks) {
                const int prev = id(oq_flow_last_good_pwm);
                if (abs(prev - pwm_local) >= good_pwm_step) {
                  id(oq_flow_last_good_pwm) = pwm_local;
                }
                stable_cnt = stable_time_ticks;
              }
            } else {
              stable_cnt = 0;
            }
            return pwm_local;
          };

          const int cm_code = id(oq_control_mode_code);
          const bool is_cm0 = (cm_code == 0);

          // Flow submode select (within CM1/CM2/CM3): AUTO vs MANUAL PWM
          const int flow_mode_code = (id(oq_flow_control_mode).active_index().value_or(0) == 1) ? 1 : 0;
          id(oq_flow_control_mode_code) = flow_mode_code;
          const bool want_manual = (flow_mode_code == 1);
          static bool was_manual = false;

          // Edge 1: entering active control from CM0
          if (was_cm0 && !is_cm0) {
            start_auto_transition("CM0->*");
          }
          was_cm0 = is_cm0;

          if (is_cm0) {
            // Keep manual-edge memory synchronized while idle.
            was_manual = want_manual;
            id(oq_flow_mode).publish_state("CM0");
            publish_debug(FLOW_MODE_CM0, cm_code, (int) id(oq_flow_last_pwm));
            return;
          }

          const bool is_frost = (cm_code == 98);

          int mode = is_frost ? 2 : 0; // 0=AUTO, 2=FROST
          if (mode != id(oq_flow_last_mode)) {
            id(oq_flow_i) = 0.0f;
            sp_f = NAN;
            stable_cnt = 0;
          }
          id(oq_flow_last_mode) = mode;

          // Autotune temporarily overrides PWM (flow_control remains output owner).
          if (id(oq_flow_autotune_active) && (cm_code == 1) && !is_frost) {
            int at_pwm = clamp_iPWM((int) id(oq_flow_autotune_pwm));
            id(oq_flow_last_pwm) = at_pwm;
            stable_cnt = 0;
            pi_failsafe = false;
            write_pump_pwm_if_changed(id(hp1_pump_speed), at_pwm);
            write_pump_pwm_if_changed(id(hp2_pump_speed), at_pwm);
            if (last_mode != "AUTOTUNE") {
              id(oq_flow_mode).publish_state("AUTOTUNE");
              last_mode = "AUTOTUNE";
            }
            publish_debug(FLOW_MODE_AUTOTUNE, cm_code, at_pwm);
            return;
          }

          // Edge 2: leaving MANUAL to AUTO
          if (was_manual && !want_manual) {
            start_auto_transition("MANUAL->AUTO");
          }
          was_manual = want_manual;

          int pwm = clamp_iPWM((int) id(oq_flow_last_pwm));
          FlowExecMode exec_mode = FLOW_MODE_AUTO;

          // Fixed-output modes first, AUTO PI as fallback.
          if (want_manual && !is_frost) {
            pwm = (int) roundf(id(oq_flow_manual_pwm).state);
            pwm = clamp_iPWM(pwm);
            stable_cnt = 0;
            pi_failsafe = false;
            sp_f = NAN;
            exec_mode = FLOW_MODE_MANUAL;
          } else if (is_frost) {
            pwm = (int) roundf(id(oq_flow_frost_pwm).state);
            pwm = clamp_iPWM(pwm);
            stable_cnt = 0;
            pi_failsafe = false;
            exec_mode = FLOW_MODE_FROST;
          } else {
            pwm = run_auto_pi(pwm);
            if (pi_failsafe) {
              exec_mode = FLOW_MODE_AUTO_FAILSAFE;
            } else if (startup_hold > 0) {
              exec_mode = FLOW_MODE_AUTO_STARTING;
            } else {
              exec_mode = FLOW_MODE_AUTO;
            }
          }

          pwm = clamp_iPWM(pwm);
          id(oq_flow_last_pwm) = pwm;

          write_pump_pwm_if_changed(id(hp1_pump_speed), pwm);
          write_pump_pwm_if_changed(id(hp2_pump_speed), pwm);

          // External mode text has explicit priority and updates only on change.
          std::string mode_txt;
          switch (exec_mode) {
            case FLOW_MODE_FROST: mode_txt = "CM98"; break;
            case FLOW_MODE_MANUAL: mode_txt = "MANUAL"; break;
            case FLOW_MODE_AUTO_FAILSAFE: mode_txt = "AUTO (failsafe)"; break;
            case FLOW_MODE_AUTO_STARTING: mode_txt = "AUTO (starting)"; break;
            default: mode_txt = "AUTO"; break;
          }
          if (mode_txt != last_mode) {
            id(oq_flow_mode).publish_state(mode_txt.c_str());
            ESP_LOGI("flow", "Flow mode=%s (cm=%s manual=%d failsafe=%d hold=%d pwm=%d)",
                     mode_txt.c_str(), id(oq_control_mode).state.c_str(), (int)want_manual, (int)pi_failsafe, startup_hold, pwm);
            last_mode = mode_txt;
          }

          publish_debug(exec_mode, cm_code, pwm);
