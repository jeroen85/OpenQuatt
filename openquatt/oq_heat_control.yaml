# ==============================================================================
# OpenQuatt â€“ Heat Control Core (shared)
# ==============================================================================
#
# Goal:
#   Shared state, telemetry and controls for heat allocation.
#
# Role in architecture:
#   Provides shared inputs/outputs for setup-specific allocation policies.
#
# What this package DOES do:
#   - Consumes oq_demand_raw (producer in oq_heating_strategy)
#   - Applies demand filtering to damp noise/jitter in heat demand
#   - Defines shared tuning inputs and state (`oq_demand_filtered`, capacity/deficit)
#   - Publishes setup-agnostic telemetry in diagnostics/overview
#
# What this package DOES NOT do:
#   - Has no dedicated temperature PID loop (strategy owns temperature-loop behavior)
#   - Does not implement flow interlock (flow-control + supervisory are leading)
#   - Does not determine Control Mode
#   - Does not control boiler directly (boiler follows CM3)
#
# Key assumptions:
#   - `oq_demand_raw` is available from strategy and scaled to `f` range (0-20)
#   - Compressor levels are `select` entities with options '0'..'10'
#
# Interaction with Control Modes:
#   - Policy modules enforce CM gating and actuator writes.
#
# ==============================================================================

# ----------------------------
# TUNING INPUTS
# ----------------------------
number:
  - platform: template
    id: oq_min_runtime_min
    name: "Minimum runtime"
    icon: mdi:timer-cog-outline
    unit_of_measurement: "min"
    min_value: 0
    max_value: 240
    step: 1
    mode: slider
    restore_value: true
    optimistic: true
    initial_value: 30
    web_server:
      sorting_group_id: oq_tuning_heat

  - platform: template
    id: oq_demand_filter_ramp_up_step_min
    name: "Demand filter ramp up"
    icon: mdi:stairs-up
    unit_of_measurement: "step/min"
    min_value: 1
    max_value: 20
    step: 1
    mode: slider
    restore_value: true
    optimistic: true
    initial_value: 1
    web_server:
      sorting_group_id: oq_tuning_heat

# ----------------------------
# GLOBALS
# ----------------------------
globals:
  # Filtered demand (0..20)
  - id: oq_demand_filtered
    type: int
    restore_value: false
    initial_value: '0'

  # Power House telemetry (W)
  - id: oq_P_hp_cap_w
    type: float
    restore_value: false
    initial_value: '0.0'

  - id: oq_P_deficit_w
    type: float
    restore_value: false
    initial_value: '0.0'

# ----------------------------
# SENSORS (energie + status)
# ----------------------------
sensor:
  - platform: template
    id: oq_total_power_input
    name: "Total Power Input"
    icon: mdi:flash
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    accuracy_decimals: 2
    update_interval: 10s
    web_server:
      sorting_group_id: oq_performance
    lambda: |-
      auto nz = [](float value) -> float { return isnan(value) ? 0.0f : value; };
      const float hp1_power_w = nz(id(hp1_power_input).state);
      const float hp2_power_w = nz(${oq_expr_hp2_power_w});
      return hp1_power_w + hp2_power_w;

  - platform: template
    id: oq_total_heat_power
    name: "Total Heat Power"
    icon: mdi:radiator
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    accuracy_decimals: 0
    update_interval: 10s
    web_server:
      sorting_group_id: oq_performance
    lambda: |-
      const float hp1_heat_w = id(hp1_heat_power).state;
      const float hp2_heat_w = ${oq_expr_hp2_heat_w};

      if (isnan(hp1_heat_w) && isnan(hp2_heat_w)) return NAN;
      if (isnan(hp1_heat_w)) return hp2_heat_w;
      if (isnan(hp2_heat_w)) return hp1_heat_w;

      return hp1_heat_w + hp2_heat_w;

  - platform: template
    id: oq_total_cop
    name: "Total COP"
    icon: mdi:chart-bell-curve-cumulative
    state_class: measurement
    accuracy_decimals: 2
    update_interval: 10s
    web_server:
      sorting_group_id: oq_performance
    lambda: |-
      const float total_input_w = id(oq_total_power_input).state;
      const float total_heat_w = id(oq_total_heat_power).state;

      if (isnan(total_input_w) || isnan(total_heat_w)) return NAN;
      if (fabsf(total_input_w) < ${oq_cop_min_input_w}) return NAN;

      return total_heat_w / total_input_w;

  - platform: template
    id: oq_demand_raw_sensor
    name: "Demand raw"
    icon: mdi:chart-line
    unit_of_measurement: "step"
    state_class: measurement
    accuracy_decimals: 0
    update_interval: 5s
    web_server:
      sorting_group_id: oq_diagnostics
    lambda: |-
      return (float) id(oq_demand_raw);

  - platform: template
    id: oq_demand_filtered_sensor
    name: "Demand filtered"
    icon: mdi:chart-line-variant
    unit_of_measurement: "step"
    state_class: measurement
    accuracy_decimals: 0
    update_interval: 5s
    web_server:
      sorting_group_id: oq_diagnostics
    lambda: |-
      return (float) id(oq_demand_filtered);

  - platform: template
    id: oq_hp1_compressor_level_sensor
    name: "HP1 compressor level"
    icon: mdi:stairs
    unit_of_measurement: "lvl"
    state_class: measurement
    accuracy_decimals: 0
    update_interval: 5s
    web_server:
      sorting_group_id: oq_diagnostics
    lambda: |-
      if (!id(hp1_compressor_level).has_state()) return NAN;
      auto idx = id(hp1_compressor_level).active_index();
      if (!idx.has_value()) return NAN;
      return (float) idx.value();

  - platform: template
    id: oq_hp2_compressor_level_sensor
    name: "HP2 compressor level"
    icon: mdi:stairs
    unit_of_measurement: "lvl"
    state_class: measurement
    accuracy_decimals: 0
    update_interval: 5s
    web_server:
      sorting_group_id: oq_diagnostics
    lambda: |-
      const float level = ${oq_expr_hp2_last_applied_level};
      return isnan(level) ? NAN : level;

# ----------------------------
# Extra overview sensors for capacity deficit
# ----------------------------

  - platform: template
    id: oq_hp_capacity_w_sensor
    name: "HP capacity (W)"
    icon: mdi:radiator
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    accuracy_decimals: 0
    update_interval: 5s
    web_server:
      sorting_group_id: oq_overview
    lambda: |-
      return id(oq_P_hp_cap_w);

  - platform: template
    id: oq_hp_deficit_w_sensor
    name: "HP deficit (W)"
    icon: mdi:alert-circle-outline
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    accuracy_decimals: 0
    update_interval: 5s
    web_server:
      sorting_group_id: oq_overview
    lambda: |-
      return id(oq_P_deficit_w);

text_sensor:
  - platform: template
    id: oq_runtime_lead_hp_sensor
    name: "Runtime lead HP"
    icon: mdi:source-branch
    update_interval: 10s
    web_server:
      sorting_group_id: oq_diagnostics
    lambda: |-
      const float hp2_minutes_raw = ${oq_expr_hp2_runtime_min};
      if (isnan(hp2_minutes_raw)) return std::string("HP1");
      const int hp2_minutes = (int) lroundf(hp2_minutes_raw);
      const bool lead_is_hp1 = (id(hp1_minutes) <= hp2_minutes);
      return std::string(lead_is_hp1 ? "HP1" : "HP2");

# ----------------------------
# BUTTON
# ----------------------------
button:
  - platform: template
    id: oq_reset_runtime
    name: "Reset Runtime Counters"
    icon: mdi:restart
    web_server:
      sorting_group_id: oq_tuning_heat
    on_press:
      - lambda: |-
          id(hp1_minutes) = 0;
          ${oq_stmt_hp2_runtime_reset}
          ESP_LOGW("quatt", "Runtime counters reset.");
